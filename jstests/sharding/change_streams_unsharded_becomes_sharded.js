// Tests the behavior of change streams on a collection that was initially unsharded but then
// becomes sharded. In particular, test that post-shardCollection inserts update their cached
// 'documentKey' to include the new shard key, and that a resume token obtained prior to the
// shardCollection command can be used to resume the stream even after the collection has been
// sharded.
// @tags: [uses_change_streams]
(function() {
    "use strict";

    load('jstests/libs/change_stream_util.js');  // For ChangeStreamTest.

    // For supportsMajorityReadConcern().
    load("jstests/multiVersion/libs/causal_consistency_helpers.js");

    if (!supportsMajorityReadConcern()) {
        jsTestLog("Skipping test since storage engine doesn't support majority read concern.");
        return;
    }

    const testName = "change_streams_unsharded_becomes_sharded";
    const st = new ShardingTest({
        shards: 2,
        mongers: 1,
        rs: {
            nodes: 1,
            enableMajorityReadConcern: '',
            // Use a higher frequency for periodic noops to speed up the test.
            setParameter: {periodicNoopIntervalSecs: 1, writePeriodicNoops: true}
        }
    });

    const mongersDB = st.s0.getDB("test");
    const mongersColl = mongersDB[testName];

    function testUnshardedBecomesSharded(collToWatch) {
        mongersColl.drop();
        mongersDB.createCollection(testName);
        mongersColl.createIndex({x: 1});

        st.ensurePrimaryShard(mongersDB.getName(), st.rs0.getURL());

        // Establish a change stream cursor on the unsharded collection.
        const cst = new ChangeStreamTest(mongersDB);

        // Create a different collection in the same database, and verify that it doesn't affect the
        // results of the change stream.
        const mongersCollOther = mongersDB[testName + "other"];
        mongersCollOther.drop();
        mongersDB.createCollection(testName + "other");
        mongersCollOther.createIndex({y: 1});

        let cursor = cst.startWatchingChanges({
            pipeline: [{$changeStream: {}}, {$match: {"ns.coll": mongersColl.getName()}}],
            collection: collToWatch
        });
        assert.eq(0, cursor.firstBatch.length, "Cursor had changes: " + tojson(cursor));

        // Verify that the cursor picks up documents inserted while the collection is unsharded. The
        // 'documentKey' at this point is simply the _id field.
        assert.writeOK(mongersColl.insert({_id: 0, x: 0}));
        assert.writeOK(mongersCollOther.insert({_id: 0, y: 0}));
        const[preShardCollectionChange] = cst.assertNextChangesEqual({
            cursor: cursor,
            expectedChanges: [{
                documentKey: {_id: 0},
                fullDocument: {_id: 0, x: 0},
                ns: {db: mongersDB.getName(), coll: mongersColl.getName()},
                operationType: "insert",
            }]
        });

        // Record the resume token for this change, before the collection is sharded.
        const preShardCollectionResumeToken = preShardCollectionChange._id;

        // Shard the test collection with shard key {x: 1} and split into 2 chunks.
        st.shardColl(mongersColl.getName(), {x: 1}, {x: 0}, false, mongersDB.getName());

        // Shard the other collection with shard key {y: 1} and split into 2 chunks.
        st.shardColl(mongersCollOther.getName(), {y: 1}, {y: 0}, false, mongersDB.getName());

        // List the changes we expect to see for the next two operations on the sharded collection.
        // Later, we will resume the stream using the token generated before the collection was
        // sharded, and will need to confirm that we can still see these two changes.
        const postShardCollectionChanges = [
            {
              documentKey: {x: 1, _id: 1},
              fullDocument: {_id: 1, x: 1},
              ns: {db: mongersDB.getName(), coll: mongersColl.getName()},
              operationType: "insert",
            },
            {
              documentKey: {x: -1, _id: -1},
              fullDocument: {_id: -1, x: -1},
              ns: {db: mongersDB.getName(), coll: mongersColl.getName()},
              operationType: "insert",
            }
        ];

        // Verify that the cursor on the original shard is still valid and sees new inserted
        // documents. The 'documentKey' field should now include the shard key, even before a
        // 'kNewShardDetected' operation has been generated by the migration of a chunk to a new
        // shard.
        assert.writeOK(mongersColl.insert({_id: 1, x: 1}));
        assert.writeOK(mongersCollOther.insert({_id: 1, y: 1}));
        cst.assertNextChangesEqual(
            {cursor: cursor, expectedChanges: [postShardCollectionChanges[0]]});

        // Move the [minKey, 0) chunk to shard1.
        assert.commandWorked(mongersDB.adminCommand({
            moveChunk: mongersColl.getFullName(),
            find: {x: -1},
            to: st.rs1.getURL(),
            _waitForDelete: true
        }));
        assert.commandWorked(mongersDB.adminCommand({
            moveChunk: mongersCollOther.getFullName(),
            find: {y: -1},
            to: st.rs1.getURL(),
            _waitForDelete: true
        }));

        // Make sure the change stream cursor sees a document inserted on the recipient shard.
        assert.writeOK(mongersColl.insert({_id: -1, x: -1}));
        assert.writeOK(mongersCollOther.insert({_id: -1, y: -1}));
        cst.assertNextChangesEqual(
            {cursor: cursor, expectedChanges: [postShardCollectionChanges[1]]});

        // Confirm that we can resume the stream on the sharded collection using the token generated
        // while the collection was unsharded, whose documentKey contains the _id field but not the
        // shard key.
        let resumedCursor = cst.startWatchingChanges({
            pipeline: [{$changeStream: {resumeAfter: preShardCollectionResumeToken}}],
            collection: mongersColl
        });

        // Verify that we see both of the insertions which occurred after the collection was
        // sharded.
        cst.assertNextChangesEqual(
            {cursor: resumedCursor, expectedChanges: postShardCollectionChanges});

        // Test the behavior of a change stream when a sharded collection is dropped and recreated.
        cursor = cst.startWatchingChanges({
            pipeline: [{$changeStream: {}}, {$match: {"ns.coll": mongersColl.getName()}}],
            collection: collToWatch
        });
        assert.eq(0, cursor.firstBatch.length, "Cursor had changes: " + tojson(cursor));

        // Insert a couple documents to shard1, creating a scenario where the getMore to shard0 will
        // indicate that the change stream is invalidated yet shard1 will still have data to return.
        assert.writeOK(mongersColl.insert({_id: -2, x: -2}));
        assert.writeOK(mongersColl.insert({_id: -3, x: -3}));

        // Drop and recreate the collection.
        mongersColl.drop();
        mongersDB.createCollection(mongersColl.getName());
        mongersColl.createIndex({z: 1});

        // Shard the collection on a different shard key and ensure that each shard has a chunk.
        st.shardColl(mongersColl.getName(), {z: 1}, {z: 0}, {z: -1}, mongersDB.getName());

        assert.writeOK(mongersColl.insert({_id: -1, z: -1}));
        assert.writeOK(mongersColl.insert({_id: 1, z: 1}));

        // Verify that the change stream picks up the inserts, however the shard key is missing
        // since the collection has since been dropped and recreated.
        cst.assertNextChangesEqual({
            cursor: cursor,
            expectedChanges: [
                {
                  documentKey: {_id: -2},
                  fullDocument: {_id: -2, x: -2},
                  ns: {db: mongersDB.getName(), coll: mongersColl.getName()},
                  operationType: "insert",
                },
                {
                  documentKey: {_id: -3},
                  fullDocument: {_id: -3, x: -3},
                  ns: {db: mongersDB.getName(), coll: mongersColl.getName()},
                  operationType: "insert",
                }
            ]
        });

        cst.cleanUp();
    }

    // First test against a change stream on a single collection.
    testUnshardedBecomesSharded(mongersColl.getName());

    // Test against a change stream on the entire database.
    testUnshardedBecomesSharded(1);

    st.stop();
})();
